; connect:
;   - keyboard adapter to device 0
;   - hex display to device 1


%define BUFFER_PAGE 0x1f ; last page of memory is where we'll store the keystrokes

%define STATUS      0xff ; last byte of 0 page is where we'll store current status

.org 0x0
    nop
    nop
    mov     0x01,           SS ; set the stack to be on the second page; we'll be using the first page
    mov     BUFFER_PAGE,    RC ; load the start address to RC:RD
    xor     RD,             RD ; xoring a value with itself sets it 0
reset:
    mov     0,          [STATUS]
    xor     RA,             RA

loop:
    and     RD,             RD ; check RD
    jz      loop               ; if it's 0 continue
    sid                        ; we don't want interrupts while consulting the buffer
    dec     RD                 ; decrement RD so it points to the latest character
    mov     [RC:RD],        RB ; move the current key to RB
    cid
    cmp     RB,             0x20; first, check for a space
    jz      new_number
    cmp     RB,             0x0A; then for a line feed
    jz      compute
    lcall   parse_hex_digit    ; call parse_hex_digit, which will store in RB the parsed hex digit
    cmp     RB,             0xFF; if the call returned 0xFF, the digit was invalid
    jz      loop
    shl     RA                  ; by now RB contains a value between 0x0 and 0xF. Let's shift it into RA
    shl     RA                  ; first we shift RA left 4 times
    shl     RA
    shl     RA
    add     RA,             RB  ; then we add RB
    goto    loop
new_number:
    push    RD                  ; in this section we need RD for indirect page 0 addressing, so we save it
    mov     [STATUS],       RD  ; move our result to were STATUS points to
    mov     RA,             [RD]
    inc     RD                  ; then increment status
    mov     RD,         [STATUS]
    pop     RD
    xor     RA,             RA  ; clear the input
    goto loop
compute:
    push    RD
    mov     [STATUS],       RD  ; load the content of STATUS to RD
    xor     RA,             RA  ; reset RA
_compute_loop:
    and     RD,             RD  ; if it's 0, go back to loop
    jz      _compute_end
    dec     RD
    mov     [RD],           RB
    add     RA,             RB
    goto    _compute_loop
_compute_end:
    pop     RD
    mov     RA,         [0x6000] ; send the total to the LCD display
    goto reset

parse_hex_digit:
    sub     RB,             0x30 ; subtract the ASCII code for 0
    jn      invalidchar         ; if the result is negative, it definitely wasn't a valid digit
    cmp     RB,             9   ; compare it with 9
    jn      digit               ; if <= 9, the user typed a digit
    jz      digit

    sub     RB,             0x11; if it's not a digit it might be a hex letter digit 
                                ; subtract the remaining to get to 0x41 (ASCII code for 'A')
    jn      invalidchar         ; again, if it's negative at this point it's invalid
    cmp     RB,             5
    jn      letterdigit         ; if <= 5, the user typed a hex letter digit
    jz      letterdigit

    sub     RB,             0x20 ; if it's not an uppercase letter digit, it might be a lowercase a-f
                                 ; subtract the remaining to get to 0x61 (ASCII code for'a')
    jn      invalidchar          ; same here, we jump if it's in the range between upper and lower alphabet
    cmp     RB,             5
    jn      letterdigit
    jz      letterdigit
invalidchar:
    mov     0xFF,           RB  ; if we reached here the character is invalid 
    ret                         ; store 0xFF to signal the calling fuction that the digit is invalid

letterdigit:
    add     RB,             0xA ; because of the way we parse letter digits, we need to add 0xA before the next steps
digit:
    ret



.org 0x1f00
    push    RA
    mov     [0x4000],       RA ; check if available
    and     RA,             RA
    jz      not_keyboard
    mov     [0x4001],       RA ; retrieve the value
    mov     RA,          [RC:RD] ; store it in the buffer
    inc     RD                   ; increment the buffer pointer
    pop     RA

not_keyboard:
    iret